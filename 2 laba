#include <stdlib.h>
#include <iomanip>
#include <tuple>
#include <stdio.h>
#include <iostream>
#include <string.h>
#include <vector>
#include <cmath>
#include <type_traits>
using namespace std;


struct Base {//базовая структура
	bool Delete = false;
};
//8. Номер рейса, пункт назначения, время вылета, дата вылета, стоимость билета.

struct Variant8 : Base {
	int number;
	char place[50];
	char time[50];
	char data[50];
	int price;
};


template<typename AStruct, typename = std::enable_if<std::is_base_of<Base, AStruct>::value>> //создать шаблон и потом можно использовать при любых типах переменных (Astruct), наследуется от Basa (плюс структура Delete) 
class Base_a {
private:
	Variant8 *_baseMas;
	long _base_aSize;
	char* _base_aName;

	void exchange(AStruct* ap, AStruct* bp) {//метод поменять местами
		AStruct per = *ap;
		*ap = *bp;
		*bp = per;
	}

public:
	Base_a(int length, string base_aName) {
		_base_aName = new char[base_aName.length() + 1];//выделяют новую память для объекта строки
		_base_aSize = length;
		strcpy(_base_aName, base_aName.c_str());//с помощью функции копируем base_aName в _base_aName

		_baseMas = new Variant8[length]; //выделяют новую память для объекта

		for (size_t i = 0; i < _base_aSize; i++)//size_t счетчик цикла, более точный, чем тип int
			_baseMas[i].Delete = true;
	}
	~Base_a() {//деструктор для освобождения памяти
		delete[] _base_Mas;
	}


	/*1. “Очистка” структурных переменных (отметка переменной как не
содержащей данных). Функция должна получать в качестве параметра индекс
массива.
*/
	void Delete_ind(int index) { //метод для удаления
		_baseMas[index].Delete = true;
	}


	/*2. Поиск свободной структурной переменной. Функция должна возвращать
индекс первого свободного элемента в массиве структур.*/
	int FindEmptyper() {
		for (size_t i = 0; i < _base_aSize; i++)
			if (_baseMas[i].Delete)
				return i; //если выполняется, то возвращается индекс этой переменной, если нет, то -1
		return -1;
	}


/*3. Ввод элементов (полей) структуры с клавиатуры. В качестве параметра в
функцию должен передаваться индекс элемента массива*/
	void Add_el( AStruct base, int index) {
		_baseMas[index] = base;
		_baseMas[index].Delete = false;//если добавляем элемент, то поле занято
	}


	/*4. Вывод элементов (полей) структуры на монитор. В функцию должен
передаваться индекс элемента массива.*/
	AStruct Get_el(int index) {
		return _baseMas[index];
	}

	/*5. Вывод на экран всех заполненных элементов массива структур.*/
	vector<AStruct> GetALL_el() {//создать динамический массив типа шаблона с помощью вектора
		vector<AStruct> result; //еще динамический массив типа шаблона
		for (size_t i = 0; i < _base_aSize; i++)
			if (!_baseMas[i].Delete)//если не удален
				result.push_back(_baseMas);//функция добавления элементов в вектор
		retutn result;
	}

	/*6. Поиск в массиве структур элемента с заданным значением поля или с
наиболее близким к нему по значению. Предусмотреть возможность задания
одного числового значения и одного строкового.
*/
	AStruct* FindNearEl(int (*selectorFunction)(AStruct), int searchEl) {//создаем анонимную функцию (лямбду) (объявляются в месте использоания и не получают уникального идентификатора для доступа к ним). int (*selectorFunction)(AStruct) принмает AStruct и возвращает int, а в нее передаем элемент массива, сравнивая с searchEl 
		int index_nearEl = -1;
		int min = INT_MAX;

		for (size_t i=0; i< _base_aSize; i++)
			if (!_baseMas[i].Delete) {
				int valueMin = abs(selectorFunction(_baseMas[i]) - searchEl);

				if (valueMin < min) {
					min = valueMin;
					index_nearEl = i;
				}
			}
		return index_nearEl == -1 ? (AStruct*)NULL : &_baseMas[index_nearEl];
		//принимает структуру и элемент, который нужно найти, или близкий
}

	AStruct* FindNearString(string(*selectorFunction)(AStruct),string searchEl) {
		for (size_t i = 0; i < _baseSize; i++)
			if (!_baseMas[i].Delete && selectorFunction(_baseMas[i]).find(searchEl) != string::npos) //вводим константу, обозначающую несуществующий индекс в массиве
				return &_baseMas[i];
		return NULL;
	}
	

	/*7. Поиск в массиве структуры с минимальным значением заданного поля.
Поле должно передаваться в поле числом, обозначающим номер поля в
структуре.*/
template<typename AValue>
AStruct* FindMin(AValue(*selectorFunction)(Astruct)) {//вводим новый шаблонный тип 
	AValue min = selectorFunction(_baseMas[0]);
	int indexMinEl = -1;
	for (size_t i=0; i < _base_aSize; i++)
	if (!_baseMas[i].Delete && selectorFunction(_baseMas[i]<=min)
	{
		indexMinEl=1;
			min= selectorFunction(_baseMas[i]);
	}
	return indexMinEl == -1 ? (AStuct*)NULL : &_baseMas[indexMinEl];

}
 
/*8. Сортировка массива структур в порядке возрастания заданного поля (при
сортировке можно использовать тот факт, что в Си++ разрешается присваивание
структурированных переменных);*/

/*9. Сортировка массива структур в порядке убывания заданного поля (при
сортировке можно использовать тот факт, что в Си++ разрешается присваивание
структурированных переменных);
*/
void Sort(bool (*selection)(AStruct, AStruct)) {//сортировка пузырьком
	for (int i = 0; i < _base_aSize - 1; i++)
		for (int j = 0; j < _base_aSize - i - 1; j++)
			if (selection(_baseMas[j], _baseMas[j + 1]))
				swap(&_baseMas[j], &_baseMas[j + 1]);//функция для замены двух переменных

}

/*10. Функция чтения файла с содержимым базы данных (массива структурных
элементов).*/
void Read() {
	FILE* file = fopen(_base_aName, "rb");//двоичный вид  записи

	for (size_t i = 0; i < _base_aSize; i++)
		fread(&_baseMas[i], sizeof(AStruct), 1, file);
	fclose(file);
}

/*11. Функция записи в файл содержимого базы данных (массива структурных
элементов).*/

void Save() {
	FILE* file = fopen(_base_aName, "wb");//для записи не текста

	for (size_t i = 0; i < _base_aSize; i++)
		fwrite(&_baseMas[i], sizeof(AStruct), 1, file);
	fclose(file);
}
};


int main() {
	setlocale(LC_CTYPE, "Russian");
	int SizeofDB;
	string NameofDB;
	int change;
	int cou;
	int numForClean;
	int numForPrint;
	Variant8 first;
	vector<Variant8> all;
    char find;

	cout << "Введите размер и имя бд: " <<"\nРазмер: ";
	cin >> SizeofDB;
	cout << "Имя: ";
	cin >> NameofDB;

	Base_a<Variant8>* database = new Base_a<Variant8>(SizeofDB, NameofDB);
	do {
		cout << "\nВыбор: \n1.Ввод элементов в бд \n2.Очистка элементов в бд \n3.Поиск свободной переменной  \n4.Вывод одного элемента  \n5.Вывод всей бд  \n6.Поиск с заданным значением поля  \n7.Сортировка  \n8.Сохранение бд в файл  \n 9.Чтение записей из файла   \n0.Выход из программы\n" << endl;
		cin >> change;
		switch (change) {
		case 1:
			cout << "\n\nКоличество необходимых записей в бд: ";
			do {
				cin >> cou;
			} while (cou > SizeofDB);
			for (size_t j = 0; j < cou; j++) {
				Variant8 structure;
				cout << "\nНомер рейса: ";
				cin >> structure.number;
				cout << "\nПункт назначения: ";
				cin >> structure.place;
				cout << "\nВремя вылета (в строку): ";
				cin >> structure.time;
				cout << "\nДата вылета (в строку): ";
				cin >> structure.data;
				cout << "\nСтоимость билета: ";
				cin >> structure.price;

				database->Add_el(structure, j);
				cout << "\nДобавлено " << j + 1 << "из " << cou << endl;

			}
			break;

		case 2:
			cout << "\n\nОчистить элемент. Введите его номер (от 0): ";
			cin >> numForClean;
			while (numForClean >= SizeofDB) {
				cout << "\nОшибка, введите другое значение: ";
				cin >> numForClean;
			}
				database->Delete_ind(numForClean);
				break;
		case 3:
			cout << "\n\nПервая свободная переменная: " << database->FindEmptyper();
			break;
		case 4:
			cout << "\n\nНомер элемента, который нужно вывести (с нуля): ";
			cin >> numForPrint;
			while (numForPrint >= SizeofDB) {
				cout << "\nОшибка, введите другое значение: ";
				cin >> numForPrint;
			}
			first = database->Get_el(numForPrint);
			cout << first.number << "\n" << first.place << "\n" << first.time << "\n" << first.data << "\n" << first.price;
			break;
		case 5:
			cout << "\n\nБаза данных:\n" << database->FindEmptyper();
			all = database->GetALL_el();
			cout << "Номер рейса" << setw(10) << "Пункт назнач" << setw(10) << "Время вылета" << setw(10) << "Дата вылета" << setw(10) << "Стоимость билета" << endl;
			for (size_t i = 0; i < all.size(); i++)
				cout << all[i].number << "  " << all[i].place << "  " << all[i].time << "  " << all[i].data << "  " << all[i].place;
			break;



            
        case 6:
            cout << "\nНажмите i - для числового типа, s - для строкового: ";
            cin >> find;
            switch (find) {
            case 'i':
                cout << "\n Искать: n-номер рейса , p-пункт назначения , a- ,  сеанс - S, цену - C или аудиторию - A" << endl;
                cin >> findMinInt;
                switch (findMinInt) {
                case 'C':
                    cout << "Цена для поиска: ";
                    cin >> cost;
                    cout << "Искомая цена: ";
                    minByCost = database->findIntElement([](Film p) { return p.costFilm; }, cost);
                    if (minByCost == NULL)
                        cout << "NotFound!" << endl;
                    else
                        cout << minByCost->nameFilm << " " << minByCost->sessionFilm << " " << minByCost->costFilm << " " << minByCost->auditoriaofFilm << endl;
                    break;
                case 'n':
                    cout << "Сеанс для поиска: ";
                    cin >> session;
                    cout << "Искомый номер сеанса: ";
                    minBySession = database->findIntElement([](Film p) { return p.sessionFilm; }, session);
                    if (minBySession == NULL)
                        cout << "NotFound!" << endl;
                    else
                        cout << minBySession->nameFilm << " " << minBySession->sessionFilm << " " << minBySession->costFilm << " " << minBySession->auditoriaofFilm << endl;
                    break;
                case 'A':
                    cout << "Аудитория для поиска: ";
                    cin >> auditoria;
                    cout << "Мскомая аудитория: ";
                    minByAuditoria = database->findIntElement([](Film p) { return p.auditoriaofFilm; }, auditoria);
                    if (minByAuditoria == NULL)
                        cout << "NotFound!" << endl;
                    else
                        cout << minByAuditoria->nameFilm << " " << minByAuditoria->sessionFilm << " " << minByAuditoria->costFilm << " " << minByAuditoria->auditoriaofFilm << endl;
                    break;
                }break;

            case 'n':

                cout << "Имя для поиска: ";
                cin >> name;
                resByStr = database->findStringElement([](Film p) { return string(p.nameFilm); }, name);
                if (resByStr == NULL)
                    cout << "NotFound!" << endl;
                else
                    cout << resByStr->nameFilm << " " << resByStr->sessionFilm << " " << resByStr->costFilm << " " << resByStr->auditoriaofFilm << endl;




            }break;


        case 7:

            cout << "Выберите тип сортировки: минимальное по строке - 1, минимальное по числу - 2, по возрастанию - 3, по убыванию - 4." << endl;
            cin >> typeSorting;
            switch (typeSorting) {
            case 1:
                minByName = database->FindMinimal<string>([](Film p) { return string(p.nameFilm); });
                cout << "Min by Name: " << minByName->nameFilm << " " << minByName->sessionFilm << " " << minByName->costFilm << " " << minByName->auditoriaofFilm << endl;
                break;
            case 2:
            {
                int findMinInt;
                cout << "Что будем искать? сеанс - 1, цену - 2 или аудиторию - 3" << endl;
                cin >> findMinInt;
                switch (findMinInt) {
                case 2:
                    cout << "Минимальная цена: ";
                    minByCost = database->FindMinimal<int>([](Film p) { return p.costFilm; });
                    if (minByCost == NULL)
                        cout << "NotFound!" << endl;
                    else
                        cout << minByCost->nameFilm << " " << minByCost->sessionFilm << " " << minByCost->costFilm << " " << minByCost->auditoriaofFilm << endl;
                    break;
                case 1:
                    cout << "Минимальный номер сеанса: ";
                    minBySession = database->FindMinimal<int>([](Film p) { return p.sessionFilm; });
                    if (minBySession == NULL)
                        cout << "NotFound!" << endl;
                    else
                        cout << minBySession->nameFilm << " " << minBySession->sessionFilm << " " << minBySession->costFilm << " " << minBySession->auditoriaofFilm << endl;
                    break;
                case 3:
                    cout << "Наименьшая аудитория: ";
                    minByAuditoria = database->FindMinimal<int>([](Film p) { return p.auditoriaofFilm; });
                    if (minByAuditoria == NULL)
                        cout << "NotFound!" << endl;
                    else
                        cout << minByAuditoria->nameFilm << " " << minByAuditoria->sessionFilm << " " << minByAuditoria->costFilm << " " << minByAuditoria->auditoriaofFilm << endl;
                    break;
                }

            } break;
            case 3:
            {

                int insrt;
                cout << "Критерий сортировки: название - 1, цена - 2, аудитория - 3, сеанс - 4" << endl;
                cin >> insrt;
                switch (insrt) {
                case 1:
                    database->Sorting([](Film p1, Film p2) { return string(p1.nameFilm) > string(p2.nameFilm); });
                    cout << "Сортировка по возрастанию имени: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;
                case 2:
                    database->Sorting([](Film p1, Film p2) { return int(p1.costFilm) > int(p2.costFilm); });
                    cout << "Сортировка по возрастанию цены: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;

                case 3:
                    database->Sorting([](Film p1, Film p2) { return int(p1.auditoriaofFilm) > int(p2.auditoriaofFilm); });
                    cout << "Сортировка по возрастанию аудитории: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;

                case 4:
                    database->Sorting([](Film p1, Film p2) { return int(p1.sessionFilm) > int(p2.sessionFilm); });
                    cout << "Сортировка по возрастанию сеанса: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;



                }
            }break;

            case 4:
            {

                cout << "Критерий сортировки: название - 1, цена - 2, аудитория - 3, сеанс - 4" << endl;
                cin >> insrt;
                switch (insrt) {
                case 1:
                    database->Sorting([](Film p1, Film p2) { return string(p1.nameFilm) < string(p2.nameFilm); });
                    cout << "Сортировка по убыванию имени: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;
                case 2:
                    database->Sorting([](Film p1, Film p2) { return int(p1.costFilm) < int(p2.costFilm); });
                    cout << "Сортировка по убыванию цены: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;

                case 3:
                    database->Sorting([](Film p1, Film p2) { return int(p1.auditoriaofFilm) < int(p2.auditoriaofFilm); });
                    cout << "Сортировка по убыванию аудитории: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;

                case 4:
                    database->Sorting([](Film p1, Film p2) { return int(p1.sessionFilm) < int(p2.sessionFilm); });
                    cout << "Сортировка по убыванию сеанса: " << endl;
                    allAfterSort = database->printAllElemtnts();
                    for (size_t i = 0; i < allAfterSort.size(); i++)
                        cout << allAfterSort[i].nameFilm << " " << allAfterSort[i].sessionFilm << " " << allAfterSort[i].costFilm << " " << allAfterSort[i].auditoriaofFilm << endl;
                    break;

                }
            }

            }break;
        case 8:
            database->Save();
            cout << "Сохранено.\n";
            break;

        case 9:
            database->Restore();
            cout << "Прочитано.\n";
            break;



        case -1:
            cout << "Работа закончена."; break;


        }
    } while (instractionFromPerson != -1);

    return 0;
}
