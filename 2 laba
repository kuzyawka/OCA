#include <stdlib.h>
#include <iomanip>
#include <tuple>
#include <stdio.h>
#include <iostream>
#include <string.h>
#include <vector>
#include <cmath>
#include <type_traits>
using namespace std;


struct Base {//базовая структура
	bool Delete = false;
};
//8. Номер рейса, пункт назначения, время вылета, дата вылета, стоимость билета.

struct Variant8 : Base {
	int number;
	char place[50];
	char time[50];
	char data[50];
	int price;
};


template<typename AStruct, typename = std::enable_if<std::is_base_of<Base, AStruct>::value>> //создать шаблон и потом можно использовать при любых типах переменных (Astruct), наследуется от Basa (плюс структура Delete) 
class Base_a {
private:
	AStruct *_baseMas;
	long _base_aSize;
	char* _base_aName;

	void exchange(AStruct* ap, AStruct* bp) {//метод поменять местами
		AStruct per = *ap;
		*ap = *bp;
		*bp = per;
	}

public:
	Base_a(string base_aName, long length) {
		_base_aName = new char[base_aName.length() + 1];//выделяют новую память для объекта строки
		strcpy(_base_aName, base_aName.c_str());//с помощью функции копируем base_aName в _base_aName

		_baseMas = new AStruct[length]; //выделяют новую память для объекта
		_base_aSize = length;

		for (size_t i = 0; i < _base_aSize; i++)//size_t счетчик цикла, более точный, чем тип int
			_baseMas[i].Delete = true;
	}
	~Base_a() {//деструктор для освобождения памяти
		delete[] _base_Mas;
	}


	/*1. “Очистка” структурных переменных (отметка переменной как не
содержащей данных). Функция должна получать в качестве параметра индекс
массива.
*/
	void Delete_ind(int index) { //метод для удаления
		_baseMas[index].Delete = true;
	}


	/*2. Поиск свободной структурной переменной. Функция должна возвращать
индекс первого свободного элемента в массиве структур.*/
	int FindEmptyper() {
		for (size_t i = 0; i < _base_aSize; i++)
			if (_baseMas[i].Delete)
				return i; //если выполняется, то возвращается индекс этой переменной, если нет, то -1
		return -1;
	}


/*3. Ввод элементов (полей) структуры с клавиатуры. В качестве параметра в
функцию должен передаваться индекс элемента массива*/
	void Add_el(int index, AStruct base) {
		_baseMas[index] = base;
		_baseMas[index].Delete = false;//если добавляем элемент, то поле занято
	}


	/*4. Вывод элементов (полей) структуры на монитор. В функцию должен
передаваться индекс элемента массива.*/
	AStruct Get_el(int index) {
		return _baseMas[index];
	}

	/*5. Вывод на экран всех заполненных элементов массива структур.*/
	vector<AStruct> GetALL_el() {//создать динамический массив типа шаблона с помощью вектора
		vector<AStruct> result; //еще динамический массив типа шаблона
		for (size_t i = 0; i < _base_aSize; i++)
			if (!_baseMas[i].Delete)//если не удален
				result.push_back(_baseMas);//функция добавления элементов в вектор
		retutn result;
	}

	/*6. Поиск в массиве структур элемента с заданным значением поля или с
наиболее близким к нему по значению. Предусмотреть возможность задания
одного числового значения и одного строкового.
*/
	AStruct* FindNearEl(int (*selectorFunction)(AStruct), int searchEl) {//создаем анонимную функцию (лямбду) (объявляются в месте использоания и не получают уникального идентификатора для доступа к ним). int (*selectorFunction)(AStruct) принмает AStruct и возвращает int, а в нее передаем элемент массива, сравнивая с searchEl 
		int index_nearEl = -1;
		int min = INT_MAX;

		for (size_t i=0; i< _base_aSize; i++)
			if (!_baseMas[i].Delete) {
				int valueMin = abs(selectorFunction(_baseMas[i]) - searchEl);

				if (valueMin < min) {
					min = valueMin;
					index_nearEl = i;
				}
			}
		return index_nearEl == -1 ? (AStruct*)NULL : &_baseMas[index_nearEl];
		//принимает структуру и элемент, который нужно найти, или близкий
}

	AStruct* FindNearString(string(*selectorFunction)(AStruct),string searchEl) {
		for (size_t i = 0; i < _baseSize; i++)
			if (!_baseMas[i].Delete && selectorFunction(_baseMas[i]).find(searchEl) != string::npos) //вводим константу, обозначающую несуществующий индекс в массиве
				return &_baseMas[i];
		return NULL;
	}
	

	/*7. Поиск в массиве структуры с минимальным значением заданного поля.
Поле должно передаваться в поле числом, обозначающим номер поля в
структуре.*/
template<typename AValue>
AStruct* FindMin(AValue(*selectorFunction)(Astruct)) {//вводим новый шаблонный тип 
	AValue min = selectorFunction(_baseMas[0]);
	int indexMinEl = -1;
	for (size_t i=0; i < _base_aSize; i++)
	if (!_baseMas[i].Delete && selectorFunction(_baseMas[i]<=min)
	{
		indexMinEl=1;
			min= selectorFunction(_baseMas[i]);
	}
	return indexMinEl == -1 ? (AStuct*)NULL : &_baseMas[indexMinEl];

}
 
/*8. Сортировка массива структур в порядке возрастания заданного поля (при
сортировке можно использовать тот факт, что в Си++ разрешается присваивание
структурированных переменных);*/

/*9. Сортировка массива структур в порядке убывания заданного поля (при
сортировке можно использовать тот факт, что в Си++ разрешается присваивание
структурированных переменных);
*/
void Sort(bool (*f)(AStruct, AStruct)) {//сортировка пузырьком
	for (int i = 0; i < _base_aSize - 1; i++)
		for (int j = 0; j < _base_aSize - i - 1; j++)
			if (f(_baseMas[j], _baseMas[j + 1]))
				swap(&_baseMas[j], &_baseMas[j + 1]);//функция для замены двух переменных

}

/*10. Функция чтения файла с содержимым базы данных (массива структурных
элементов).*/
void Read() {
	FILE* file = fopen(_base_aName, "rb");//двоичный вид  записи

	for (size_t i = 0; i < _base_aSize; i++)
		fread(&_baseMas[i], sizeof(AStruct), 1, file);
	fclose(file);
}

/*11. Функция записи в файл содержимого базы данных (массива структурных
элементов).*/

void Save() {
	FILE* file = fopen(_base_aName, "wb");//для записи не текста

	for (size_t i = 0; i < _base_aSize; i++)
		fwrite(&_baseMas[i], sizeof(AStruct), 1, file);
	fclose(file);
}
};


int main() {
	setlocale(LC_CTYPE, "Russian");
	int SizeofDB;
	string NameofDB;
	int change;
	int cou;

	cout << "Введите размер и имя бд: " <<"\nРазмер: ";
	cin >> SizeofDB;
	cout << "Имя: ";
	cin >> NameofDB;

	Base_a<Variant8>* database = new Base_a<Variant8>(SizeofDB, NameofDB);
	do {
		cout << "\nВыбор: \n1.Ввод элементов в бд \n2.Очистка элементов в бд \n3.Поиск свободной переменной  \n4.Вывод одного элемента  \n5.Вывод всей бд  \n6.Поиск с заданным значением поля  \n7.Сортировка  \n8.Сохранение бд в файл  \n 9.Чтение записей из файла   \n0.Выход из программы\n" << endl;
		cin >> change;
		switch (change) {
		case 1:
			cout << "Количество необходимых записей в бд: ";
			do {
				cin >> cou;
			} while (cou > SizeofDB);
			for (size_t j = 0; j < cou; j++) {
				Variant8 structure;
				cout << "\nНомер рейса: ";
				cin >> structure.number;
				cout << "\nПункт назначения: ";
				cin >> structure.place;
				cout << "\nВремя вылета (в строку): ";
				cin >> structure.time;
				cout << "\nДата вылета (в строку): ";
				cin >> structure.data;
				cout << "\nСтоимость билета: ";
				cin >> structure.price;

				database->Add_el(structure, j);
				cout << "Добавлено " << j + 1 << "из " << cou << endl;

			}
			break;

		case 2:


		}
	}
}
